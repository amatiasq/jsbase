if (typeof module !== 'undefined' && module.exports === exports) {
	var sinon = require('sinon');
	var expect = require('../lib/expect');
	var fn = require('../src' + (process.env['CODE_COVERAGE'] ? '-cov' : '') + '/fn');
}

describe('Functional helpers', function() {

	describe('#prop function', function() {

		describe('with a single argument', function() {
			var sut = fn.prop('key');

			it('should return a function', function() {
				expect(sut).toBeFunction();
			});
			it('should return a function who will retrieve the property from its argument', function() {
				expect(sut({ key: 'hola' })).toBe('hola');
			});
			it('should return undefined if the object does not have the property', function() {
				expect(sut({})).toBeUndefined();
			});
			it('should crash if the argument is null or undefined', function() {
				expect(function() { sut() }).toThrowError();
				expect(function() { sut(null) }).toThrowError();
			});
		});

		describe('with two arguments', function() {
			var sut = fn.prop('key', 'hola');
			it('should assing the property of its argument if #prop recives two arguments', function() {
				var obj = {};
				sut(obj)
				expect(obj.key).toBe('hola');
			});
			it('should return the new property value if #prop recives two arguments', function() {
				expect(sut({})).toBe('hola');
			});
		});
	});

	describe('#funct function', function() {

		describe('with a single argument', function() {
			var sut = fn.funct('get');

			it('should return a function', function() {
				expect(sut).toBeFunction();
			});
			it('should return a function who will invoke the method from its argument', function() {
				var spy = sinon.spy();
				sut({ get: spy });
				expect(spy.calledOnce).toBeTrue();
			});
			it('should return a function who will return the value generated by the invocation', function() {
				expect(sut({ get: function() { return 'hola' } })).toBe('hola');
			});
			it('should crash if the object does not have a method with the given name', function() {
				expect(function() { sut({}) }).toThrowError();
			});
			it('should crash if no argument is passed', function() {
				expect(function() { sut() }).toThrowError();
				expect(function() { sut(null) }).toThrowError();
			});
		});

		describe('with more arguments', function() {
			it('should invoke the method from its argument passing extra args as method arguments', function() {
				var spyOneArg = sinon.spy();
				var spyTwoArgs = sinon.spy();

				fn.funct('get', 'key')({Â get: spyOneArg });
				fn.funct('set', 'key', 'value')({ set: spyTwoArgs });

				expect(spyOneArg.calledWithExactly('key')).toBeTrue();
				expect(spyTwoArgs.calledWithExactly('key', 'value')).toBeTrue();
			});
		});
	});

	describe('#returner function', function() {
		it('should return a function who returns the first passed argument', function() {
			expect(fn.returner('hola')()).toBe('hola');
			expect(fn.returner()()).toBeUndefined();
		});
	});

	describe('#pipe function', function() {
		it('should return its first argument', function() {
			expect(fn.pipe('hola')).toBe('hola');
		})
	});
});
